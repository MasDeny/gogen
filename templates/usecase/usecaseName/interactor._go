package {{LowerCase .Name}}

import (
	"context"
	"fmt"

	"{{.PackagePath}}/usecase/{{LowerCase .Name}}/port"
)

// New{{PascalCase .Name}}Usecase ...
func New{{PascalCase .Name}}Usecase(outputPort port.{{PascalCase .Name}}Outport) port.{{PascalCase .Name}}Inport {
	return &{{CamelCase .Name}}Interactor{
		datasource: outputPort,
	}
}

type {{CamelCase .Name}}Interactor struct {
	datasource port.{{PascalCase .Name}}Outport
}

// Handle ...
func (_r *{{CamelCase .Name}}Interactor) Handle(ctx context.Context, req port.{{PascalCase .Name}}Request) (*port.{{PascalCase .Name}}Response, error) {

	{
		response, err := _r.datasource.IsExist(ctx, port.IsExistRequest{ //
			Name: req.Name,
		})
		if err != nil {
			return nil, err
		}
		if response.YesItHas {
			return nil, fmt.Errorf("product with name %s already exist", req.Name)
		}
	}

	var productID int
	{

		if req.Price <= 0 {
			return nil, fmt.Errorf("product price must > 0")
		}

		res, err := _r.datasource.SaveProduct(ctx, port.SaveProductRequest{ //
			ProductName: req.Name,
			Price:       req.Price,
		})

		if err != nil {
			return nil, err
		}

		productID = res.ID
	}

	return &port.{{PascalCase .Name}}Response{ //
		ID: productID,
	}, nil
}