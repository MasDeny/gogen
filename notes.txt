
addon later
    nambahin transaction
    nambahin default gorm dan gin
    perbaiki error_func
    tambahkan const
    perbaiki enum
    bisa pilih log library
    create new usecase will create new interactor
    create new test will adding new unexisting method
    tambahin komen di tiap template
    tambahkann traceID


gogen2 gateway prod CreateOrder
gogen2 gateway prod CreateOrder ShowOrder
gogen2 gateway prod *
gogen2 gateway prod.mobile CreateOrder

usecase
    menerima nama usecase
    akan membuat folder usecase/<namausecase>
    membuat 3 file yaitu inport.go, outport.go dan interactor.go dibawah folder tersebut
    next feature: jika dipanggil untuk kedua kalinya, maka akan membuat file interactor baru
    dengan diberi tambahan index sesuai jumlah interactor dibelakang nama interactor baru tersebut

test
    menerima nama test dan nama usecase
    akan membaca Outport yang berisi semua method yang dibutuhkan untuk menjalankan usecase tersebut
    membuat file test dibawah folder usecase yang sesuai dengan nama testcase_<namatest>_test.go
    nextfeature: jika dipanggil untuk kedua kalinya
    maka akann menambahkan method yang mungkin baru saja ditambahkan di Outport usecase

entity
    menerima nama entity
    membuat file entity dengan nama entity dibawah folder domain/entity/<namaentity>.go
    jika dipanggil untuk kedua kalinya maka akan muncul pesan error

error
    menerima nama error
    membuatkan struktur folder dibawah application/apperror
    jika belum ada, membuat error_func.go file yang berisi fungsionalitas umum untuk error
    jika belum ada, membuat error_enum.go file yang berisi koleksi error code dan message
    jika file error_enum.go sudah ada maka hanya akan menambahkan error line nya saja
    jika dipanggil untuk kedua kalinya maka akan muncul pesan error

repository
    menerima nama repository, nama entity dan nama usecase sebagai parameter opsional
    jika file repository.go belum ada, maka akan membuat folder dan file domain/repository/repository.go
    jika entity belum ada, maka akan membuatkan entity dibawah domain/entity/<namaentity>.go
    jika menerima nama usecase, maka akan menginjeksikan repo tersebut didalam struct Outport
    jika diberi injection point didalam interactor, maka akan menginjeksikan code repository

gateway
    menerima nama gateway dan nama usecase
    membaca Outport dari usecase dan mengkoleksi semua method dari Outport tersebut
    jika belum ada, membuat folder dan file gateway/<namagateway>/implementation.go
    membuat struct Gateway yang berisi semua method dari Outport usecase tersebut
    jika dipanggil untuk kedua kalinya maka baca dan koleksi semua function yang sudah ada dari
    struct Gateway tersebut, yang mana beberapa implementasi mungkin saja sudah dipindah ke file lain
    perintah kedua kalinya ini hanya akan menambahkan function baru saja ke dalam implementation.go

controller
    menerima nama controller dan nama usecase
    membuat folder controller/<namacontroller>
    membuat file controller/controller.go berisi interface
    membuat file controller/<namacontroller>/response.go
    membuat file controller/<namacontroller>/interceptor.go
    membuat file controller/<namacontroller>/handler_<namausecase>.go
    membuat file controller/<namacontroller>/router.go
    menginjeksikan inport yang sesuai usecase kedalam struct Controller
    menginjeksikan router yang sesuai kedalam method RegisterRouter

registry
    menerima nama registry dan nama controller
    akan membaca semua usecase yang terdaftar dalam controller
    coba membaca gateway, jika cuma 1 gateway, maka akan langsung dipakai
    jika ada lebih dari 1 gateway, maka akan diminta untuk memilih
    jika filenya sudah ada maka akan diberi pesan info saja
    membuat folder application/registry
    membuat file application/application.go berisi interface
    membuat file application/<namaregistry>.go berisi implementation

Method
    read entity
    create an entity's method

ValueObject
    create a valueobject

ValueString
    create a valuestring

Enum
    create an enum
    create error


Mapper

Init

Config

Template


https://betterprogramming.pub/rpc-in-golang-19661033942
https://medium.com/rungo/building-rpc-remote-procedure-call-network-in-go-5bfebe90f7e9

kalo implementasi gateway ada di struct lain? kita harus bisa handle dan tidak perlu di extend lagi

Controller dikategorikan berdasarkan actor yang mengakses usecase
    user api
    backoffice api
    dev api
    webhook api

<ControllerName>Controller
    RegisterHandler()
    handle<UsecaseName>(inport)

Read Gateway
    Kita cari outport interface dari usecase yang di inginkan
    baca seluruh field interface nya
    ada 4 kemungkinan dari field tsb
    1. berupa extension interface lain yang berada di package yang berbeda
    2. berupa extension interface lain yang berada di dalam package dan file yang sama : BELUM DIHANDLE
    3. berupa extension interface lain yang berada di dalam package namun file yang berbeda : BELUM DIHANDLE
    4. berupa direct method
        jika parameter punya type yang berada di packgae yg sama : BELUM DIHANDLE

    tujuannya adalah mengkoleksi semua method yang dibutuhkan

usecase
test
entity
repository
application
gateway
error
controller

registry
service
valueobject
valuestring
enum
init
config

why we are using an architecture?
- because we must manage many service
- because we have to handle the interaction between service
- because development is never stop
- because we want to sleep better

there are 3 types of architecture:
- "yang penting bisa jalan" architecture
- "ikut-ikutan" architecture
- "well concepted" architecture

how the memory/cpu performance when using this archietcture?
- is not a relevant question because
- what we want to achieve in architecture is performance in development process
- it doesnt mean we ignore the memory/cpu performance

why using a code generator?
- because we are lazy
- we immediately want to focus on business process instead of ceremony and boilerplate code
- we want consistent structure

why or when you are using "copy and paste" instead of code generator?
- when you are lazy to use code generator
- but you need to assure the structure

3 phase on achieve something
- motivation -> why
- theory -> what (limitation, known, unknown)
- practise -> how

step by step how to work with this architecture:
- create the usecase and entity
- create the gateway
- create the controller
- create the registry

i recommend you to design the class diagram first and the interaction between class
but sometime you can just start from usecase if you think that you handle the class diagram later.
sometimes both
can thinking on how do we store some information
how do we perform some action and which data is added or updated after an that

before you start coding, you must have and understand
- the big picture of system
- clear design and data structure of your system
- the usecases of specific system

we can answer all question from product design

every system must pay respect each other
one system must not access the data directly

usecase
- usecase is first class citizen
- put the respect to the usecase
- usecase driven approach paradigm
- always start concepting system from usecase
- usecase say everything about the system
- usecase don't care what technology you use
- usecase is a blackbox
- usecase basically manage interaction between entity and run some action
- usecase said
    - i don't care how the way you are calling me but if you want to run me, i need you to do two things:
    - input some params in inport, and i don't care wherever you get it from
    - fullfil anything in outport, and i don't care how you implement it

too many usecase is also a code smell.
when a project has so many usecase we need to separate it into the other repo project

make sure to always return error and handle it. never ever ignore it
if we call a method and the not return (error == nil) means this method is success

problem on controller-service-repository
- one repo has many method
- one service has many repo
- one class has may service as usecase
- many usecase in one file

- we want to separate logic code and infrastructure code
- save time because we think less for naming (one of "hardest" think in programming), conventions and structure
- Increase readability, scream arcitecture
- built for lazy developer
- consistent structure
- gogen is zero dependency
- gogen is not engine it just a "well written code" so there is no performance issue
- registry name is an application name
- the power of copy and paste
- deleting is easier than creating
- gogen support multiple application in one repo
- sequence diagram explain the usecase per user task
- implement trace id in every usecase Request
- support lazy documentation. no need to work twice only to write/update doc
- thinking in oop perspective first instead of database perspective.
- gogen is not to eliminate boilerplate code. but for helping you write a code layout
- suitable for new project and revamp existing project per service
- allow you to do code modification for experimental purpose without changing the current implementation
- Private/internal struct for controller
- manual depedency injection

Fact
- all repository is interface
- almost all the repository only have one method
- controller may call multi usecase via inport
- service can be a simple function or an interface
- All method in repository and service have a context in its first params

ideally repository interface has only one method on it
then in what condition an interface can have more than one method?
- when the client of that interface guarantee will call one or more from all the method on it
- sample : repository for transaction that have begin commit and rollback

violation of interface method
- when one of method is guarantee will never called

benefit of simple interface
- easy to mock and test simulation

what is handled by entity
- collection data as object
- action related to that object only
- use other entity
- use value object

what should you only call/do in interactor?
- any method available in Outport (repository/service)
- entity
- value object
- do the simple logic like looping condition checking

what can you put in InportRequest?
- simple builtin data type as field
- we can also expose the func for advanced usage

what can you put in InportResponse?
- we can expose simple builtin data type (more recommended)
- we can also expose our Entity or Value Object

can we use entity as database structure?
- i recommend not to use it to database structure
- create the other structure in gateway is better but you must create a mapper for this

what you can declare in Outport?
- (mostly) repository
- service
- direct method

how to decide whether to use service instead of direct method?
- it is depend on the question "are we will sharing it to other usecase?"
- if we think that we want to share the method to other usecase then put it to the service
- otherwise put it as direct method in outport
- we can promoted direct method to service if it is used by other usecase

what is entity
- mutable object that has an id
- two entity is a same object if the id is similar even all of the field value is different
- entity can be a aggregate for other entity
- entity has its own factory method as constructor

what is value object?
- imutable object that all the field combination as an id
- two value object is a same object if all of the field value is different
- changing single value on any field will make it treated as different object

why we need value object?
- to objectify the value instead of using primitive datatype, for ex:
- address has a street, number, city,
- price has a amount, currency and must not negative (depend on bussiness process)

what will handled by repository?
- anything that related to data storage
- Find, Save, Delete, or Update data
- always passing the entity or primitve type
- make sure not use a loot of parameter

if you find a lot of parameter inf a function/method
then it can be wrapped to the struct

what is handled by service (when we use service?)
- anything that is not related to data storage
- anything that cannot be handled by method entity
- when it is hard to find to which Entity that behavior belongs
- contains business invariants that are too complex to be stored in a single Entity or Value Object
- generating id which used in interactor
- publishing message to message broker
- basically it is an interface. But it can be a function that has a repository and entity
- does not hold any state

how to naming the controller?
- we are naming it by the actor who is accessing it
- for example: mobileapi, userapi, restapi, backoffice, consumer, webhook

how to naming the registry?
- we are naming it by your application/service name
- for ex: paymentservice, shippingservice, backofficeservice

how to naming the gateway?
- we are naming it by your enviroment
- you can using different gateway if you want to make a simulation without changing the existing implementation
- for ex: prod (for production), local (for local db), experimental, mockdb, inmemory

how to naming the usecase?
- use simple 2 or 3 word that describe the action

there are two types of usecase
- command (or called an action)
- query (displaying information only without changing the data)

who is using infrastructure?
- controller: log, server, consumer, util, token
- gateway: log, database, publisher, util, token, cache
- registry: log,

make sure to naming bool variable as positif word

when to use panic?
- when you first time initialize the system
- never call it in runtime method otherwise your system will stop and crash suddenly

any repository, service or method in entity at least always return the error
any repository and service method must have context.Context in its first params

You are not allowed to call util directly from entity or service

service may include the repository

avoid init method

follow the rule even you are not understand yet

what is benefit of using the repository/service interface instead of make your own method?
- you can reuse the existinng implementation without writing the new one

what if you want to create your own implementation but still using existing repository/service interface?
- you can create your own method on outport
- or you can create your own implementation in gateway by create new gateway

sample case:
- upload image to Google Content Store



